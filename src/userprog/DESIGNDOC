                     +--------------------------+
       	       	     |          CS 124          |
                     | PROJECT 4: USER PROGRAMS |
                     |     DESIGN DOCUMENT      |
                     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Tim Holland <tholland@caltech.edu>
Daniel Kong <dkong@caltech.edu>
Daniel Wang <dwang@caltech.edu>

>> Specify how many late tokens you are using on this assignment:

>> What is the Git repository and commit hash for your submission?

   Repository URL: https://github.com/dkong1796/pintos-hkw.git
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

                           ARGUMENT PASSING
                           ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?
We used strtok_r to split the string into space-separated tokens, then
use the pointer to esp to push each token onto the stack. When we do
this, we each memory location in an array, and place a NULL at the end
of the array. Then, we word-align the stack and iterate through the array
of memory addresses backwards, ensuring that our arguments are push in 
the correct order. We then push argc and a dummy return value.
To avoid overflowing the stack page, we check to ensure that the length
of the arguments plus the length of the argument pointers plus the 
additional things pushed onto the stack (argc, NULL, dummy return, word-
align) does not exceed page size. If it does, we terminate the process.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?
strtok_r is reentrant, so it is a thread safe function. strtok is not, and
has undefined behavior if called from multiple threads. Since we have a
lot of concurrency going on, we want the thread safe version, since it
will be safer and more correct than strtok.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.
If the shell does this, we can cut out unnecessary code from the kernel, 
making it easier to maintain and closer to the microkernel ideal. This
improves the scalability of the kernel without trading too much in
performance.
In addition, if we keep the argument parsing in user space, we don't need
to worry so much about checking invalid memory, since this is already done
by the kernel. Since we're in user space, we handle this through segfaults
and existing syscall code. This cuts down on the amount of error-checking 
code that needs to be written, improving code readability. 

                             SYSTEM CALLS
                             ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
In lib/kernel, vector.h and vector.c are an entirely new implementation
of a dynamic array (C++ vector). The functions and fields associated 
with the vector are documented in those files.
In /threads/thread.h: added struct vector files to struct thread.
This vector keeps track of file descriptors and open files for the associated
thread.
In thread.h: struct lock filesys_lock
This lock prevents more than one thread from using the filesys code.
TODO: exit_status stuff------------------------------------------------------------

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?
File descriptors are kept in a dynamic array on a per-process basis, so each
file descriptor is only unique within a single process. This dynamic array,
files, contains a list of file *s that point to the approriate file. To
find the file associated with descriptor fd, we return the pointer at
index fd in file.data. When closing files, we set the pointer at the closed
fd to NULL. When we open a new file, we insert the file pointer at the first
NULL seen, or append it to the end of the array if no NULLs were found.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.
After ensuring stack and argument adresses are valid, we examine the buffer
pointer as well as the buffer + size - 1. We also ensure that the file
descriptor given to us is valid (non-null and not STDIN/STDOUT for write
and read, respectively). If any of these checks fail, we exit with status
-1.
For reading, we have a special case if fd == STDIN_FILENO that calls
input_getc to read from the keyboard. Otherwise, we acquire the filesys
lock and call the file_read function on the file in index fd of the files
vector of the current thread. We release the lock and return the value
passed to us by the filesys function.
For writing, we have a special case if fd == STDOUT_FILENO that calls
putbuf to write to the console. Otherwise, similar to read, we acquire
the filesys lock, call the file_write function, release the lock, and
return the value passed to us.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?
The maximum number of page table inspections is 2 for both 4096 and
2 bytes. For 4096, it is unlikely that there exists much room for
improvement without wasting a lot of memory, since there exists only one
possible arrangement of memory that will allow the data to fit on a
single page. On the other hand, for 2 bytes, we can easily ensure that
only one page is examined by checking if the data crosses a page boundary
and moving it over to the beginning of the second page. This wastes a
byte of memory, but the time savings outweigh this small cost. On the
other hand, for the 4096 byte block, if we were to do the same thing, we
would waste a much larger amount of memory, causing fragmentation issues.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.
Our syscall handler immediately checks the passed stack pointer in order to
ensure the syscall number can be obtained. We then enter into a huge switch
block, with a case for each syscall number. In each of these calls with
additional arguments, we call a function, check_args_x(), where x is 1, 2, 
or 3. This checks the validity of the arguments on the stack, and cuts
down on redundancy. If any of these checks fail, we exit with return value
-1. With this design, we centralize all of our stack/argument pointer
error checking. We still must check validity of pointers passed as arguments
to the syscalls, which is done in each individual call, but because these are
specific to the call, this decentralization is unavoidable.
When an error is detected, we free all resources by calling exit(-1). This
terminates the process and thread. In thread termination, we iterate through
the list of locks held by the thread and release all of them. In process
termination, we destroy the page directory, close open files, and delete the 
vector of file descriptors.
Suppose we have a call to close. Our program will check the passed stack
pointer for validity, then dereference it for the syscall number. Then, it
will proceed to the SYS_EXIT case and examine the single argument. It then
calls sys_close(). This function validates the file descriptor passed to it.
Suppose this check fails. Then, we call exit(-1), which causes thread
termination (releasing locks) and process termination (freeing memory and
closing files).

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?
We chose the simpler method of user memory access for ease of debugging
and maintenance. We centralized our memory checks as much as possible to
cut down on redundancy and improve code readability. For the functions
that required extra memory checks, we inserted those checks into the
calls themselves, since this was unique to those calls and therefore
made sense to be associated with the call. 

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?
By using a dynamic array, we save space inside of the thread struct,
allowing for more space for the stack. In addition, we have the
benefit of constant time random access, along with a theoretical
infinite bound to the number of open files. As a tradeoff, the complexity
of code is increased, since we wrote an entire dynamic array. It also
makes the closing of files slightly more painful, since we need to keep
track of which entries are NULL and replace them with new files if
necessary in order to save space.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?
We maintained the original identity mapping.

                           SURVEY QUESTIONS
                           ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the feedback survey on the course
website.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

