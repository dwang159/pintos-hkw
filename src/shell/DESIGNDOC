			+------------------+
			|      CS 124      |
			| PROJECT 1: SHELL |
			|  DESIGN DOCUMENT |
			+------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Tim Holland <tholland@caltech.edu>
Daniel Kong <dkong@caltech.edu>
Daniel Wang <dwang@caltech.edu>

>> Specify how many late tokens you are using on this assignment:  

>> What is the Git repository and commit hash for your submission?

   Repository URL:  
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

http://www.jera.com/techinfo/jtns/jtn002.html
cnswww.cns.cwru.edu/php/chet/readline/rltop.html
Do you want all the stack exchange links, too?

			   COMMAND SHELL
			   =============

---- DATA STRUCTURES ----

>> A1: Describe how your command shell manages parsing and executing
>> commands that contain arguments and pipes, using the example
>> command "a arg1 arg2 | b arg1 | c arg1 arg2 arg3".  How does your
>> shell internally represent such a command?

The first part of parsing is tokenization: a token is a rough approximation
of an algebraic data structure, with a type field to indicate which part of
the sum type it is, and a data field to hold a string, an int, or a pair of
ints for that token. So after the first pass, the array of tokens would look
like (fast and loose with pointers for readability):
    {token {.type = STRING, .data.str = &"a"}, 
     token {.type = STRING, .data.str = &"arg1"},
     ...
     token {.type = PIPE, .data = ?},
     token {.type = STRING, .data.str = &"b"},
    }
This is then analyzed to put into separate commands to be piped together,
specifying a list of arguments and either filenames or file descriptors for
where I/O redirection should happen on that command.

>> A2: Now, given the command:
>> "a arg1 arg2 < inp.txt | b arg1 | c arg1 arg2 arg3 > out.txt"
>> Briefly explain specifically how the redirections are parsed and
>> represented, and by what processes.

---- ALGORITHMS ----

>> A3: Illustrate how you solved the problem of setting up
>> redirection in a simple command like "a < inp.txt > out.txt", by
>> describing what process takes care of the redirection and when.

>> A4: Illustrate how you solved the problem of setting up the pipes
>> between multiple operations in a single command, by describing
>> what each process is responsible for.  For example, given the
>> command "a | b | c", describe the sequence of steps in setting up
>> the processes and their pipes, starting with your command shell's
>> process, and going through the execution of programs a, b and c.
>> Keep your description of each process' responsibilities limited to
>> ~25 words or less.

>> A5: Similarly, describe the details of how terminated processes are
>> reaped in the example command "a | b | c".

>> A6: Similarly, describe which processes are responsible for setting
>> up the redirections in the example command
>> "a < inp.txt | b | c > out.txt".

---- RATIONALE ----

>> A?: Why do the chdir and exit commands have to be implemented as
>> built-in functions, rather than external programs?

    Because they need to be run by the shell process instead of
  subprocesses. If a child process runs `cd`, it will change it's
  directory and quit but will not have affected the directory of
  the shell. If a a child exits, the parent (shell) will not have.

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

			  SURVEY QUESTIONS
			  ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the feedback survey on the course
website.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

