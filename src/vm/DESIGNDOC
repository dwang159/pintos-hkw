       	       	    +---------------------------+
                    |           CS 124          |
                    | PROJECT 5: VIRTUAL MEMORY |
                    |      DESIGN DOCUMENT      |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Timothy Holland <tholland@caltech.edu>
Daniel Kong <dkong@caltech.edu>
Daniel Wang <dwang@caltech.edu>

>> Specify how many late tokens you are using on this assignment: 2

>> What is the Git repository and commit hash for your submission?

   Repository URL: http://github.com/dkong1796/pintos-hkw.git
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.
So Donnie gave us an extension to Monday the 10th... And then
we used two late tokens to get us to Wednesday... and then we
submitted on Thursday. So that's like a day late right?
Only a 10% penalty? (have mercy?)

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.
    en.wikipedia.org/wiki/Virtual_memory

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Describes the kind of access for that entry
    enum spt_page_type {
        SPT_INVALID,
        SPT_ZERO,
        SPT_FILESYS,
        SPT_SWAP
    };

A correspondence between user page addresses and SPT entries
    struct spt_table {
        struct hash data;
    };

/* Data structure for a supplemental page table entry. */
struct spt_entry {
    // Element used to store entry in page table.
    struct hash_elem elem;

    // Key used to identify page. Should be the uaddr of the page with
    // the lower 12 bits zeroed out.
    unsigned key;

    // Page status (where to read and write data).
    enum spt_page_type read_status;
    enum spt_page_type write_status;

    // Additional data about the page, depending on the page type.
    // Struct to keep information on the location of the
    // page within the file.
    struct {
        struct file *file;
        off_t offset;
        int read_bytes;
        int zero_bytes;
    } fdata;
    
    // Used if associated with swap.
    size_t slot;

    bool writable;
    // Distinguish mapped files from loaded ones.
    bool is_mmap; /* Dist
};

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.
The faulting address can be used to index into the supplementary page table.
From there, there is a data structure that provides the decision making
about what actions to take and the data for that action.
    If the page has a read_status of SPT_ZERO, the page it is gifted
is memset to 0. If it has a read_status of SPT_FILESYS, it looks into
the fdata structure for a struct file pointer, an offset, and the number
of bytes to read and the number of bytes to zero as in load_segment. If
the read_status is SPT_SWAP, it asks the swap table to fill it's frame
with the contents numbered `slot.`

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

We avoid this issue by using dirty bits looked up in 
thread_current()->pagedir.
---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?
We used a lock around the frame allocator. If A and B fault at around
the same time, one of them will have to wait until the other is given
a frame and goes along its way until it is given one.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.


---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

A per-process hashmap between mapid_ts and fmap'd files.

/* File mapping data structure */
struct fmap_table {
    struct hash data;
};

struct fmap_entry {
    void *addr;  // The address the file is mapped into
    int fd;      // The file descriptor given by the process
    struct file *hidden; // The file is reopened by the kernel so
                         // that if the child closes it, it is still open.
    unsigned num_pages; // the number of pages for the file
    unsigned key; // the mapid for the file
    struct hash_elem elem; // Used to index into the hash table
};

// Incremented and given out each time a mapping is asked for by 
// a process.
static mapid_t key_giver = 0;
---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.
On mapping, the file's SPT entries are filled out but the file
is not loaded. Then on a fault, the page_fault handler will
consult the spt and realize to look into the file and find
the contents there.
    There is a member "is_mmap" for the spt_entry struct that indicates
whether memory belonging to a loaded file or a mapped file. If it
belongs to a loaded file, it is paged out on eviction to swap but if
it belongs to a mapped file it is written back to the file. While
the file is mapped, these SPT entries remain but are removed upon
munmap.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.
We used a hash_iterator over the supplementary page table, and
compared the start and end addresses of the new segment with
all of the old pages. For any pair of extents a1-a2 and b1-b2,
there is no overlap if 
    whenever a1 < b2, b1 >= a2 and vice versa.
    That is, whenever a starts before b ends, b starts after a ends.
We just check that this is the case for all pages currently mapped. This
could be more efficient if we just kept track of mapped segments.
---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.
It does share a lot. Probably the only major difference is in
upon a pagefault, it reads it into memory differently on
the contents of spte->is_mmap: they both have SPT_FILESYS for
their read status but loaded files have SPT_SWAP as it's write_status and
the mmapped files have SPT_FILESYS.
			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the feedback survey on the course
website.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?
This took a huge amount of time, and it was very hard. Debugging was
possible, but very difficult and required a very methodical and slow
approach.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?
Yes. I have a much better understanding of how to manage resources for
multiple "guests" simultaneously.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
Ugh.
